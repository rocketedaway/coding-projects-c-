# Union-Find (Disjoint-Set)

+ [API](#api)
  + [union] (#unionnode_a-node_b)
  + [find] (#findnode)
  + [connected] (#connectednode_a-node_b)
  + [count] (#count)
+ [Implementations](#implementations)
  + [Quick-Find](#quick-find)
  + [Quick-Union](#quick-union)
  + [Weighted-Quick-Union](#weighted-quick-union)
  + [Weighted-Quick-Union-With-Path-Compression](#weighted-quick-union-with-path-compression)
+ [References](#references)

### API

### union(node_a, node_b)
Add connection between node_a and all other nodes in the same component to the component of node_b
  + `node_a (int)` A node in the data strucutre
  + `node_b (int)` Another node in the data strucutre
  + `throws (UnionFindBoundsException)` Exception is thrown when any argument `a` is `0 > a >= N`

### find(node)
Find the component identifier which contains the specified node
  + `node (int)` A node in the data strucutre
  + `returns (int)` A component identifier
  + `throws (UnionFindBoundsException)` Exception is thrown when any argument `a` is `0 > a >= N`

### connected(node_a, node_b)
Check if a connection between node_a and and node_b exists
  + `node_a (int)` A node in the data strucutre
  + `node_b (int)` Another node in the data strucutre
  + `returns (bool)` *True* if a connection exists and *False* otherwise
  + `throws (UnionFindBoundsException)` Exception is thrown when any argument `a` is `0 > a >= N`

### count()
Query how many distinct components there are in the data structure
  + `returns (int)` The number of distinct components

## Implementations

### Quick-Find

[Source File](quick_find.py)

For this implementation, two nodes `A` and `B` are connected if and only if `components[A] == components[B]`. In the below example, if `A = 1` and `B = 3`, then they are connected because `components[A] = 1` and `components[B] = 1`.

The problem with this implementation is that in the worst case it runs in quadratic time (O(N^2)) and has trouble scaling to large data sets.

#### Underlying data structure example
```
components   (List):
--------------------
node_ids      (Indicies)     0   1   2   3   4   5   6   7
component_ids (Values)     [ 0 | 1 | 1 | 1 | 4 | 5 | 5 | 5 ]

This data defines 4 distinct components with members:
0 => { 0 }, 1 => { 1,2,3 }, 4 => { 4 }, 5 => { 5,6,7 }
```

#### Cost Model
```
|-------------|-------|------|
| Constructor | Union | Find |
|-------------|-------|------|
| N           | O(N)  | O(N) |
|-------------|-------|------|
```

### Quick-Union

[Source File](quick_union.py)

The QuickUnion implementation does things a little differently from the QuickFind implementation as it instead uses a tree structure. Given a node `A`, its parent node is the value `components[A]`. If `A == components[A]` then we know that we at the root of the tree. In order to test if two nodes `A` and `B` are connected, just check to see if they have the same root node. To connect node `C` => `D` you just make the `root(C)` be a child of `root(D)`.

The problem with this implementation is that it does not create balanced trees and execution times of both the `union` and `find` methods scale with the height of the tree.

#### Underlying data structure example:
```
components   (List):
--------------------
node_ids      (Indicies)       0   1   2   3   4   5   6   7
component_ids (Values)       [ 0 | 1 | 1 | 1 | 4 | 4 | 5 | 5 ]

The above has 3 distinct components {0, 1, 4} and defines thes following trees:

[0]      [1]       [4]
        /   \       |
      [2]   [3]    [5]
                  /   \
                [6]   [7]
```

#### Cost Model
```
|-------------|----------------|----------------|
| Constructor | Union          | Find           |
|-------------|----------------|----------------|
| N           | O(Tree height) | O(Tree height) |
|-------------|----------------|----------------|
```

### Weighted-Quick-Union

[Source File](quick_union_weighted.py)

Weighted QuickUnion builds on the QuickUnion implementation by balancing the trees that are created. The height of each component tree is recorded and when preforming the `union` operation the shortest tree is always linked to the talest tree. This ensures that the component trees generated by the `union` operations remain balanced and do not grow too tall.

#### Underlying data structure example:
```
components   (List):
--------------------
node_ids      (Indicies)       0   1   2   3   4   5   6   7
component_ids (Values)       [ 0 | 1 | 1 | 1 | 5 | 5 | 5 | 5 ]

The above has 3 distinct components {0, 1, 5} and defines thes following trees:

[0]      [1]          [5]
        /   \        / | \
      [2]   [3]   [4] [6] [7]
```

#### Cost Model
```
|-------------|----------|----------|
| Constructor | Union    | Find     |
|-------------|----------|----------|
| N           | O(lg(N)) | O(lg(N)) |
|-------------|----------|----------|
```

### Weighted-Quick-Union-With-Path-Compression

[Source File](quick_union_weighted_pc.py)

Weighted QuickUnion with Path Compression optimizes the Weighted QuickUnion implementation by ensuring that the component trees generated by the `union` operations are almost completely flat. This is done by linkning all nodes examined by the `find` operation to the root of the component.

#### Underlying data structure example:
See [Weighted-Quick-Union](#weighted-quick-union)

#### Cost Model
```
|-------------|----------------|----------------|
| Constructor | Union          | Find           |
|-------------|----------------|----------------|
| N           | Basically O(1) | Basically O(1) |
|-------------|----------------|----------------|
```

## References
+ [Coursera: Introduction to Algorithms Part I](https://www.coursera.org/learn/introduction-to-algorithms)
+ [Textbook: Algorithms 4th Edition](http://algs4.cs.princeton.edu/15uf/)
